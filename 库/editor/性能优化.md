> 此文档，是基于网上的资料进行整理的，没有实操过. 主要是针对 editor 可性能优化的点进行阐述~

> 参考文档
>
> - [编辑器探索 - MonacoEditor 代码解析中的性能优化](https://juejin.cn/post/7351004872374370358#heading-7)

# 背景

JavaScript 有一个特点，它的执行是单线程的，意味着我们在使用 JavaScript 开发软件的时候需要避免某个任务过于消耗性能导致软件崩溃。VsCode 编辑器会遇到一个典型的问题就是如何处理大文本数据。
我们以代码高亮解析的过程为例。通常来说，代码的解析过程往往是从上到下一行一行解析，直到最后一行。这种方式对于大部分场景来说是很通用的，但是对于一些比较复杂的代码，尤其是对于大文本量的代码，解析带来的消耗往往不可忽略。

下面展示了分别使用了一个流行的高亮库（HighLight.js）解析代码以及使用 Monaco-Editor 解析代码来实现代码高亮的时间消耗。

<img src="./assets/highlight.jpg" width="500">

从上面的代码中可以看出，随着代码量的增加，使用常见词法解析库解析代码的时间会随着代码量的增加而线性增加，甚至会导致网页崩溃。对于编辑器来说，它的性能确几乎不受到代码量的增加影响，始终保持在一个不错的水平（660ms）。

# 性能优化

## 1. 使用增量解析避免主线程阻塞

一次性解析 10 万行或者 100 万行不可避免需要消耗大量的 CPU 计算，导致主线程阻塞， VsCode 编辑器为了避免一次性解析带来的性能影响，主要通过将代码解析的步骤进行解耦，通过增量解析来实现避免过多一次的性能消耗。

### 基于行的解析

在 VsCode 解析高亮的过程中，它是以行为单位进行处理，我们在 Monaco-Editor 解析完一行代码后进行打印，看看他是如何处理 10 万行代码的？

HighLightjs 等其他代码解析工具，通常是基于“字符”解析，从第一个字符到最后一个字符解析完整之后返回所有的结果。与其不同的是，VsCode 编辑器将“行”作为一个解析单位，并且解析是可以随时停止的，即使当你的当前的 token 状态需要跨越多个行的时候（比如 JavaScript 中的多行注释和多行字符串），它也可以通过保存当前行的状态，停止代码解析，直到下一次解析的开始，会继续当前的解析过程。这就像一个开关一样，可以随时停止或打开解析的步骤。

### 在 requestIdleCallback 中解析行

有了优化的方式，这时候我们该考虑何时开始进行代码解析。 在 JavaScript 中，我们通常将耗时的任务放到异步队列进行延迟执行，比如使用 Promise，但是这不能完全解决处理大文本问题。我们必须找到其他更合适的处理方式。
requestIdelCallback 是一个浏览器的 API，我们每一次调用它，浏览器都会分配给用户一个短暂的空闲时间执行指定代码，常常是 10ms 以内，不要小看这个 10ms，因为 JavaScript 的执行速度是很快的，浏览器的执行引擎可以在 10ms 内做很多事情。比如在上面的例子中平均 10ms 就可以解析完 500 行代码。
VsCode 将行作为最小的解析单位，目前来看，VsCode 不过是从第一个字符解析到最后一个字符变成了从第一行解析到最后一行，本质仍需要进行全量处理。解析一行代码是很快的，我们可以利用编辑器的解析特性（可以随时暂停并重启行）， 将每一行的解析都放到一个新建的 requestIdleCallback 中，这样，就能有效避免全量处理带来的主线程阻塞。

## 2. 使用 Web Woker 实现并行解析

### requestIdleCallback 的限制

就像在开头提到的那样，一个完整的代码编辑器不止需要高亮代码，也需要完成编程语言的语法高亮，代码块的缩进分析等。
在上面的示例中，我们将代码高亮解析这个部分放在 requestIdelBack 中。利用浏览器的空闲时间执行高亮分析，可以有效地解决这用户的输入问题。然而用户的每一个编辑器操作，都需要更新当前的所有状态，因为每一个 requestIdleCallback 所分配的空闲时间是有限的，如果将其他能力的解析执行也放到这个中 requestIdleCallback 中，我们无法保证其可以在较小的时间内同时也完成额外分配的任务。
同时，JavaScript 是单线程的，意味着我们无法创建其他 requestIdelCallback 来执行语法分析或者代码嵌套等分析。为了实现多个解析并行的操作而不阻塞用户的操作，我们可以利用 web worker 的多线程能力来完成这个步骤。

### web worker 简介

在传统的 JavaScript 单线程模型中， JavaScript 运行在主线程上，会阻塞用户界面的刷新，同时对 CPU 或网络资源的高强度占用（如复杂的图形计算、大文件的读取等）也会导致网页表现出“卡死”或者反应过慢的现象。而 Web Worker 的出现，可以为 JavaScript 创建一个单独的运行环境，使得 JavaScript 可以在工作线程中运行，解放主线程，避免了影响到用户界面的刷新和交互。

## 3. 编程语言中的增量解析

通过优化的 requestIdleCallback 以及使用 web woker，可以保证编辑器的优秀性能的同时不阻塞用户的输入。就像 Vue 或者 React 的虚拟 dom 的作用一样，在编程语言解析的过程中，我们可以通过他的一些语法特性或者语法规则，在不同的语言服务中进行进一步的解析优化。
一个典型的例子就是当用户的对代码进行编辑，当用户每进行一次删除，插入等操作时，都会改变当前的内容，也就意味我们需要重新进行代码解析。
这里以代码高亮解析为例，用户的编辑操作通常只会影响到较少的行数，如果我们只处理出现“异常”的代码块部分，就可减少很多的额外工作。如下我们有一个 10w+的代码如下：

```
这里代表前方有5w行代码
*/
// 第50000行代码
const foo = () => {}
/*
后续的5万行代码...
*/
```

现在，我们将第 5000 行代码进行如下的改动（只需更新第 5000 行的 token）：

```
const foo = () => {};
```

如果我们现在只更新第 5000 行的 token，那是没问题的。但是，现在如果将第 5000 行的代码改动如下:

```
const foo = () => `str
```

在其他行的代码没有改动的情况下，可以将这行视为一个 因为`可以跨过多行，这时候，在 Monaco 中，他会将当前的反引号作为一个新的开头，对后续的 token 都视为一个多行注释，不断更新所有代码的状态直到最后一行。
