# 主流跨端方案

## 跨端技术通识
“write once, run everywhere”（一次编写，四处运行）是跨端的真谛。跨端的基本原理是：跨端引擎需实现一个渲染引擎、一个虚拟机（vm），基于这套架构实现各种组件和API；跨端容器上层对接一个UI框架，再上层的业务代码可基于容器的API实现跨端的渲染和逻辑。

- **跨平台**：指跨操作系统。
- **跨端**：指跨客户端。


## 主流跨端方案

### Web 渲染
浏览器本身就是一种跨端实现方案——只需输入网址，就能在任何端的浏览器上打开网页。若将浏览器嵌入`app`并隐藏地址栏等内容，就形成了`webview`（嵌入`app`的浏览器）。因此，只要某个端支持`webview`，就能使用这种方案跨端，且这是开发成本最小的方案。

- **核心机制**：使用原生`WebView`控件渲染HTML页面，在原生应用中定义可供H5页面访问原生能力的接口`JSBridge`，实现H5和Native双向通信，扩展H5的端侧能力。
- **本质**：依托原生应用的内嵌浏览器控件`WebView`渲染H5页面，H5 App的渲染流水线与Web页面一致，能力局限于`WebView`沙箱。
- **性能瓶颈**：与Web页面类似，存在首屏渲染优化（白屏）问题，且多了WebView初始化开销。
- **优化方案**：离线包机制——将线上加载的H5应用提前下发到本地，通过FileIO或内存直接渲染，接近原生体验。
- **进阶发展**：H5容器技术——提供丰富的内置JSAPI、增强版WebView控件及插件机制，实现功能高内聚和模块低耦合。


### 原生渲染
典型代表：`React Native`和`Weex`。

Web渲染方案虽有开发效率高、生态丰富等优势，但性能和体验不足。原生渲染方案则平衡了二者：UI层采用前端框架，通过JavaScript引擎解析JS代码，JS代码通过Bridge层调用原生组件和能力，最终渲染为原生组件，提升用户体验。


#### React Native（原生渲染）- 框架核心要点
- **架构层**：React层（UI描述）→ JSBundle → Bridge层 → Native层（原生组件/能力）。
- **线程模型**：UI线程（原生渲染）、JS线程（执行逻辑）、Shadow线程（布局计算）。
- **问题**：JS与原生通信效率低，高频交互场景（如滚动、动画）易卡顿。

### 自渲染引擎渲染
典型代表：`Flutter`。

与Web渲染（依赖WebView）、原生渲染（通过Bridge转化为原生控件）不同，自渲染引擎不依赖原生能力，而是利用更底层的渲染能力直接绘制UI。其链路更短，性能更好，且能保证多端渲染一致性。

### Flutter（自渲染）- 框架核心要点
- **架构层**：Dart App层（Widget描述）→ Framework层 → Engine层（Skia渲染）→ Embedder层（平台适配）。
- **优势**：Dart AOT编译提升执行效率，自绘UI保证一致性。


### 小程序另类跨端
小程序仍基于Web渲染方案（WebView渲染引擎、JSBridge封装、离线包机制等），但创新点在于**分离渲染层和逻辑层**，提供纯净的JavaScript运行时，多WebView架构让体验逼近原生。

- **架构**：多WebView + 双线程模型。
  - 渲染层：用WebView渲染页面（iOS用UIWebView/WKWebView，Android用WebView），多页面由多WebView接管。
  - 逻辑层：从WebView分离，用JavaScript引擎（iOS用JavaScriptCore，Android用V8）开启Worker线程执行JS代码。
  - 通信：逻辑层与渲染层通过Native层中转，网络IO通过Native层转发。
- **组件特性**：包含原生组件和非原生组件，原生组件属于原生渲染范畴，因此小程序是Web渲染和原生渲染的融合方案。

- **Web渲染方案特点**：
  - 优势：开发效率高（Web技术、门槛低、资源丰富）、动态化好（无需发版）、表现一致性佳（双端差异小）。
  - 劣势：性能较差（WebView渲染耗时、功能受沙箱限制、体验差）。
- **多端适配**：大厂小程序实现差异大，可借助`taro`、`uni-app`、`remax`等框架实现一套代码多端运行。







## 跨端本质总结
- **逻辑跨端**：通过虚拟机（如V8引擎）实现JS代码跨平台运行。
- **渲染跨端**：开发层描述UI，通过通信机制通知各端渲染层调用原生API实现绘制，框架负责封装底层差异。