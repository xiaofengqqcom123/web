# 主流跨端方案

## 跨端技术通识
“write once, run everywhere”（一次编写，四处运行）是跨端的真谛。跨端的基本原理是：跨端引擎需实现一个渲染引擎、一个虚拟机（vm），基于这套架构实现各种组件和API；跨端容器上层对接一个UI框架，再上层的业务代码可基于容器的API实现跨端的渲染和逻辑。

- **跨平台**：指跨操作系统。
- **跨端**：指跨客户端。


## 主流跨端方案

### Web 渲染
浏览器本身就是一种跨端实现方案——只需输入网址，就能在任何端的浏览器上打开网页。若将浏览器嵌入`app`并隐藏地址栏等内容，就形成了`webview`（嵌入`app`的浏览器）。因此，只要某个端支持`webview`，就能使用这种方案跨端，且这是开发成本最小的方案。

- **核心机制**：使用原生`WebView`控件渲染HTML页面，在原生应用中定义可供H5页面访问原生能力的接口`JSBridge`，实现H5和Native双向通信，扩展H5的端侧能力。
- **本质**：依托原生应用的内嵌浏览器控件`WebView`渲染H5页面，H5 App的渲染流水线与Web页面一致，能力局限于`WebView`沙箱。
- **性能瓶颈**：与Web页面类似，存在首屏渲染优化（白屏）问题，且多了WebView初始化开销。
- **优化方案**：离线包机制——将线上加载的H5应用提前下发到本地，通过FileIO或内存直接渲染，接近原生体验。
- **进阶发展**：H5容器技术——提供丰富的内置JSAPI、增强版WebView控件及插件机制，实现功能高内聚和模块低耦合。


### 原生渲染
典型代表：`React Native`和`Weex`。

Web渲染方案虽有开发效率高、生态丰富等优势，但性能和体验不足。原生渲染方案则平衡了二者：UI层采用前端框架，通过JavaScript引擎解析JS代码，JS代码通过Bridge层调用原生组件和能力，最终渲染为原生组件，提升用户体验。


### 自渲染引擎渲染
典型代表：`Flutter`。

与Web渲染（依赖WebView）、原生渲染（通过Bridge转化为原生控件）不同，自渲染引擎不依赖原生能力，而是利用更底层的渲染能力直接绘制UI。其链路更短，性能更好，且能保证多端渲染一致性。


### 小程序另类跨端
小程序仍基于Web渲染方案（WebView渲染引擎、JSBridge封装、离线包机制等），但创新点在于**分离渲染层和逻辑层**，提供纯净的JavaScript运行时，多WebView架构让体验逼近原生。

- **架构**：多WebView + 双线程模型。
  - 渲染层：用WebView渲染页面（iOS用UIWebView/WKWebView，Android用WebView），多页面由多WebView接管。
  - 逻辑层：从WebView分离，用JavaScript引擎（iOS用JavaScriptCore，Android用V8）开启Worker线程执行JS代码。
  - 通信：逻辑层与渲染层通过Native层中转，网络IO通过Native层转发。
- **组件特性**：包含原生组件和非原生组件，原生组件属于原生渲染范畴，因此小程序是Web渲染和原生渲染的融合方案。

- **Web渲染方案特点**：
  - 优势：开发效率高（Web技术、门槛低、资源丰富）、动态化好（无需发版）、表现一致性佳（双端差异小）。
  - 劣势：性能较差（WebView渲染耗时、功能受沙箱限制、体验差）。
- **多端适配**：大厂小程序实现差异大，可借助`taro`、`uni-app`、`remax`等框架实现一套代码多端运行。


## 了解 RN 原生渲染

### 整体架构
- **React 层**：用React框架描述UI，开发者通过Class Component或Function Component开发，框架将页面转化为ReactElement（虚拟DOM数据结构），用于Diff对比和消息收发。
- **JSBundle 中间产物**：通过metro打包为JSBundle，在RN应用初始化时通过Bridge层加载。
- **Bridge 层**：连接React和Native的中间层。React层UI通过UIManager接口创建/更新原生控件，通过NativeModules接口调用原生能力。
- **Native 层**：
  - Native Modules：实现与上层交互的原生能力接口。
  - Native UI：实现终端实际控件展示。
  - Yoga Layout：跨平台布局引擎，实现基于Flexbox的JS和Native镜像映射。


### RN 运行机制（线程模型）
- **UI 线程**：应用主线程，负责原生渲染、调用原生能力，处理原生控件绘制。
- **JS 线程**：解释执行JS代码。默认用JSC（JavaScriptCore）引擎；Chrome调试时用V8引擎，通过websocket与原生通信。
- **Shadow 线程**：构建JS与原生控件的布局镜像数据。通过Yoga（基于Flexbox的跨平台布局引擎）计算组件布局，维护shadow tree，再通过bridge通知native thread渲染。
- **Native Modules 线程**：提供原生能力，多线程模型（iOS用GCD，Android用AsyncTask）。


### 初始化流程
1. `native`启动原生界面（如Android的activity），进行初始化。
2. 加载JS引擎，运行JS代码（与React启动流程类似，但无法获取真实节点）。
3. `js`线程通知`shadow thread`。
4. `shadow thread`计算布局，通知`native Thread`创建原生组件。
5. `native`在界面渲染原生组件，呈现给用户。


### 更新流程
以用户点击按钮触发界面更新为例：
1. `native`获取点击事件，传给`js thread`。
2. `js thread`处理`onClick`函数，触发`setState`。
3. 与React更新流程一致，执行Diff找到需更新节点。
4. 通知`shadow thread`。
5. `shadow thread`计算布局后，通知`native thread`渲染。


### RN 方案存在的问题
**性能瓶颈**：Native层和JS层通信成本高。
- 异步通信：页面更新和事件响应需在Native与JS层来回传递，耗时较长，时效性要求高的场景（如动画、滚动）体验差。
- 序列化开销：数据交互需频繁序列化和反序列化。

**典型问题**：长列表快速滚动或跟手动画时，因交互频繁，界面可能来不及更新，出现白屏、卡顿。


### 从 RN 看本质
跨端可分为**逻辑跨端**和**渲染跨端**：
- **逻辑跨端**：通过`vm`实现（如v8引擎），让JS代码在各平台运行。
- **渲染跨端**：开发层（如RN的React代码）描述UI，但无渲染能力，需通过通信通知渲染层（各端系统）调用对应API渲染。跨端框架的核心是封装各平台API，上层调用封装后的API，底层由封装层对接真实API。

**本质**：开发层告知渲染层“想要什么”，由渲染层实现渲染。例如：
- `hybrid`方案中，`webview`是桥接层，`createElement`、`appendChild`等是封装的跨平台API。
- `flutter`自渲染引擎类似“新浏览器”，无历史包袱，架构更优。


## 了解 Flutter 自渲染引擎

### 整体架构
Flutter应用分为四层：
1. **Dart App 层**：最顶层，以Widget为基本视图描述单元构建UI体系。
2. **Flutter Framework 层**：内置基础组件，封装Material（安卓风格）和Cupertino（iOS风格）两套UI库。
3. **Flutter C++ Engine 层**：核心层，包括Dart虚拟机、Skia跨平台渲染引擎、文字排版、平台通道等，连接Dart App层和原生平台。
4. **Embedder 层**：平台嵌入层，提供宿主环境、线程创建、基于插件的原生能力扩展等。

**打包与启动**：
- 打包：Dart业务代码和Flutter Engine代码按iOS/Android平台分别打包。
- 启动：Native通过调用C++实现（Java用JNI，OC直接支持）初始化Flutter Engine，创建UI/GPU/IO线程并实例化Dart VM。Dart代码在Release模式下以AOT编译为二进制代码，运行在Dart VM中。


### 运行机制（线程模型）
- **Platform 线程**：Flutter主线程，由Native创建。负责注册平台vsync信号回调，接收显示设备的vsync信号后驱动UI线程执行。
- **UI 线程**：响应vsync信号，执行Dart层代码，驱动渲染管线，将Widget Tree生成Layer Tree并提交给GPU线程。
- **GPU 线程**：将Layer Tree转化为绘制指令，调用Skia渲染引擎光栅化上屏。
- **IO 线程**：请求图片资源并解码，生成纹理传递给GPU线程。

**渲染流程**：
显示器一帧vblank后向GPU发送vsync信号，Native的Platform线程接收后驱动UI线程绘制：
1. UI线程：Native调用C++实现，通过window对象向Dart层发送绘制指令；Dart层重构UI数据树（Widget Tree、Element Tree、RenderObject Tree），生成布局信息和Layer Tree，再通过window对象传递给GPU线程。
2. GPU线程：调用Skia渲染引擎将Layer Tree光栅化，输出帧数据到帧缓冲区显示。


### Flutter 优势
1. **直接绘制**：UI控件通过Skia跨平台渲染引擎绘制，无需转化为原生控件，保证双端一致性和性能。
2. **高效编译**：Dart在Release模式下采用AOT编译为二进制代码，执行效率高。
3. **通信高效**：UI层与原生层数据交换性能优于RN。