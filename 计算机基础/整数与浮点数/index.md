## 整数与二进制位
- 计算机使用二进制存储和传输
  - 传输的最小单位是位（bit）
  - 存储的最小单位是字节（byte），1 字节 = 8 位
  - 整数 => 表达为二进制位 => 编码为字节
- 无符号整数
  - N 位无符号整数的范围：[0, 2**N - 1]
  - 最低位（least significant bit）编为 0 位（LSB 0）
  - 最高位（most significant bit）编为 N-1 位
- 有符号整数：负数如何表达？


#### 有符号整数的负数表达
> 注意：正数的原码、反码、补码一致

- 原码（signed magnitude）
  - 最高位取反，其他位不变
  - 缺点：0 有两种表示，加减运算复杂
- 反码（ones' complement）
  - 所有位取反：-x = ~x = 2**N - 1 - x = 111...111 - x（即：原码符号位除外，其他位按位取反）
  - 缺点：0 有两种表示，加法需要补上进位
  - 反码通常是用来由原码求补码或者由补码求原码的过渡码
- 补码（two's complement）
  - 所有位取反后加 1：-x = ~x + 1 = 2**N - x ≡ -x(mod 2**N)
- 余码（excess notation）：和补码的区别是符号位相反

|  二进制 | 无符号 | 原码   | 反码  | 补码  |
|  ----  | ----  | ----  | ----  | ---- |
| 000    | 0     | 0    | 0    | 0     |
| 001    | 1     | 1    | 1    | 1     |
| 010    | 2     | 2    | 2    | 2     |
| 011    | 3     | 3    | 3    | 3     |
| 100    | 4     | -0   | -3   | -4    | 
| 101    | 5     | -1   | -2   | -3    |
| 110    | 6     | -2   | -1   | -2    |
| 111    | 7     | -3   | -0   | -1    |

#### 补码（two's complement）的优点
- 0 只有一种表示，原码和反码有 0 和 -0
- 范围更大：[-2**(N-1), 2**(N-1) - 1]
  - 原码和反码的范围：[-2**(N-1) - 1, 2**(N-1) - 1]
- 加法简单（但取负数比反码多一步加 1）
  - 反码加法：
    - 2 + (-1) = 010 + 110 = 000(进位1) = 000 + 1 = 001 = 1
  - 补码加法：2 + (-1) = 010 + 111 = 001(进位1) = 1
- 补码和无符号整数的加法、减法、结果同位数的乘法是一样的
  - X86 指令集的 add/sub（加减法）指令不区分有符号和无符号

#### 位运算
- 对二进制位（高位在左）的操作，与字节序无关
- 以下以 Java 为例（ECMAScript 抄袭了 Java 的位运算符）
- ~：按位非（Complement）
- &：按位与（AND）
- |：按位或（OR）
- ^：按位异或（XOR）
- <<：按位左移（无符号左移结果一样），右边补 0
- \>>：按位右移，左边补符号位（最高位）
- \>>>：按位无符号右移，左边补 0

